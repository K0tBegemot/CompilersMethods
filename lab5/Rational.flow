import runtime;
import ds/tuples;
import ASTTree;
import string;
import RationalStruct;
import ExecutionContext;

export{
    addRational(rat1 : Rational, rat2 : Rational) -> Rational;
    subRational(rat1 : Rational, rat2 : Rational) -> Rational;
    mulRational(rat1 : Rational, rat2 : Rational) -> Rational;
    divRational(rat1 : Rational, rat2 : Rational) -> Rational;
    calculateExpression(context : ExecutionContext) -> Rational;
    printRational(value : Rational) -> void;
}

maxRat(pair : Pair) -> Pair{
    if(pair.first > pair.second){
        Pair(pair.first, pair.second);
    }else{
        Pair(pair.second, pair.first);
    }
}

absRat(value : int) -> int{
    if(value < 0){
        value * -1;
    }else{
        value;
    }
}

euclidianGCDAlgRec(denominatorPair : Pair) -> int{
    if(denominatorPair.second == 0){
        denominatorPair.first;
    }else{
        euclidianGCDAlgRec(Pair(denominatorPair.second, denominatorPair.first % denominatorPair.second));
    }
}

euclidianGCDAlg(denominatorPair : Pair) -> int{
    pair : Pair = maxRat(denominatorPair);
    gcb : int = euclidianGCDAlgRec(pair);
    gcb;
}

rightRational(value : Rational) -> Rational{
    if(value.denominator < 0){
        Rational(value.numerator * -1, value.denominator * -1);
    }else{
        value;
    }
}

addRational(rat1 : Rational, rat2 : Rational) -> Rational{
    if(rat1.denominator == rat2.denominator){
        Rational(rat1.numerator + rat2.numerator, rat1.denominator);
    }else{
        rat1Right : Rational = rightRational(rat1);
        rat2Right : Rational = rightRational(rat2);
        gcb : int = euclidianGCDAlg(Pair(rat1Right.denominator, rat2Right.denominator));
        lcd : int = absRat(rat1Right.denominator) * (absRat(rat2Right.denominator) / gcb);
        Rational(rat1Right.numerator * (lcd / rat1Right.denominator) + rat2Right.numerator * (lcd / rat2Right.denominator), lcd);
    }
}

subRational(rat1 : Rational, rat2 : Rational) -> Rational{
    if(rat1.denominator == rat2.denominator){
        Rational(rat1.numerator - rat2.numerator, rat1.denominator);
    }else{
        rat1Right = rightRational(rat1);
        rat2Right = rightRational(rat2);
        gcb : int = euclidianGCDAlg(Pair(rat1Right.denominator, rat2Right.denominator));
        lcd : int = absRat(rat1Right.denominator) * (absRat(rat1Right.denominator) / gcb);
        Rational(rat1Right.numerator * (lcd / rat1Right.denominator) - rat2Right.numerator * (lcd / rat2Right.denominator), lcd);
    }
}

mulRational(rat1 : Rational, rat2 : Rational) -> Rational{
    Rational(rat1.numerator * rat2.numerator, rat1.denominator * rat2.denominator);
}

divRational(rat1 : Rational, rat2 : Rational) -> Rational{
    if(rat1.denominator == 1){
        if(rat2.denominator == 1){
            Rational(rat1.numerator, rat2.numerator);
        }else{
            Rational(rat1.numerator * rat2.denominator, rat2.numerator);
        }
    }else{
        if(rat2.denominator == 1){
            Rational(rat1.numerator, rat1.denominator * rat2.numerator);
        }else{
            Rational(rat1.numerator * rat2.denominator, rat1.denominator * rat2.numerator);
        }
    }
}

subaddRational(rat1 : Rational) -> Rational{
    Rational(rat1.numerator * -1, rat1.denominator);
}

calculateExpressionRec(expr : Expr, tree : Tree<Variable, Rational>) -> Rational{
    switch(expr){
        Add(e1, e2) : {
            addRational(calculateExpressionRec(e1, tree), calculateExpressionRec(e2, tree));
        };
        Sub(e1, e2) : {
            subRational(calculateExpressionRec(e1, tree), calculateExpressionRec(e2, tree));
        };
        Mul(e1, e2) : {
            mulRational(calculateExpressionRec(e1, tree), calculateExpressionRec(e2, tree));
        };
        Div(e1, e2) : {
            divRational(calculateExpressionRec(e1, tree), calculateExpressionRec(e2, tree));
        };
        Int(e1) : {
            Rational(e1, 1);
        };
        Parentheses(e1) : {
            calculateExpressionRec(e1, tree);
        }
        ReciprocalAdd(e1) : {
            subaddRational(calculateExpressionRec(e1, tree));
        }
        Variable(e1) : {
            number : Maybe<Rational> = lookupTree(tree, Variable(e1));
            value : Rational = either(number, Rational(0, 0));
            value;
        }
    }
}

calculateExpression(context : ExecutionContext) -> Rational{
    astTree : Maybe<Expr> = context.expr;
    if(isSome(astTree)){
        astTreeValue = either(astTree, Int(0));
        ret : Rational = calculateExpressionRec(astTreeValue, context.tree);
        ret;
    }else{
        Rational(0, 0);
    }
}

printRational(value : Rational) -> void{
    println(i2s(value.numerator));
    println("______________");
    println(i2s(value.denominator));
}