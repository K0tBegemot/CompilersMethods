import runtime;
import ds/tuples;
import ASTTree;
import string;
import RationalStruct;
import ExecutionContext;
import dynamic;

export{
    addRational(rat1 : Rational, rat2 : Rational) -> Rational;
    subRational(rat1 : Rational, rat2 : Rational) -> Rational;
    mulRational(rat1 : Rational, rat2 : Rational) -> Rational;
    divRational(rat1 : Rational, rat2 : Rational) -> Rational;
    calculateExpression(context : ExecutionContext) -> Rational;
    printRational(value : Rational) -> void;
}

maxRat(pair : Pair) -> Pair{
    if(pair.first > pair.second){
        Pair(pair.first, pair.second);
    }else{
        Pair(pair.second, pair.first);
    }
}

absRat(value : int) -> int{
    if(value < 0){
        value * -1;
    }else{
        value;
    }
}

euclidianGCDAlgRec(denominatorPair : Pair) -> int{
    if(denominatorPair.second == 0){
        denominatorPair.first;
    }else{
        euclidianGCDAlgRec(Pair(denominatorPair.second, denominatorPair.first % denominatorPair.second));
    }
}

euclidianGCDAlg(denominatorPair : Pair) -> int{
    pair : Pair = maxRat(denominatorPair);
    gcb : int = euclidianGCDAlgRec(pair);
    gcb;
}

rightRational(value : Rational) -> Rational{
    if(value.denominator < 0){
        Rational(value.numerator * -1, value.denominator * -1);
    }else{
        value;
    }
}

addRational(rat1 : Rational, rat2 : Rational) -> Rational{
    if(rat1.denominator == rat2.denominator){
        Rational(rat1.numerator + rat2.numerator, rat1.denominator);
    }else{
        rat1Right : Rational = rightRational(rat1);
        rat2Right : Rational = rightRational(rat2);
        gcb : int = euclidianGCDAlg(Pair(rat1Right.denominator, rat2Right.denominator));
        lcd : int = absRat(rat1Right.denominator) * (absRat(rat2Right.denominator) / gcb);
        Rational(rat1Right.numerator * (lcd / rat1Right.denominator) + rat2Right.numerator * (lcd / rat2Right.denominator), lcd);
    }
}

subRational(rat1 : Rational, rat2 : Rational) -> Rational{
    if(rat1.denominator == rat2.denominator){
        Rational(rat1.numerator - rat2.numerator, rat1.denominator);
    }else{
        rat1Right = rightRational(rat1);
        rat2Right = rightRational(rat2);
        gcb : int = euclidianGCDAlg(Pair(rat1Right.denominator, rat2Right.denominator));
        lcd : int = absRat(rat1Right.denominator) * (absRat(rat1Right.denominator) / gcb);
        Rational(rat1Right.numerator * (lcd / rat1Right.denominator) - rat2Right.numerator * (lcd / rat2Right.denominator), lcd);
    }
}

mulRational(rat1 : Rational, rat2 : Rational) -> Rational{
    Rational(rat1.numerator * rat2.numerator, rat1.denominator * rat2.denominator);
}

divRational(rat1 : Rational, rat2 : Rational) -> Rational{
    if(rat1.denominator == 1){
        if(rat2.denominator == 1){
            Rational(rat1.numerator, rat2.numerator);
        }else{
            Rational(rat1.numerator * rat2.denominator, rat2.numerator);
        }
    }else{
        if(rat2.denominator == 1){
            Rational(rat1.numerator, rat1.denominator * rat2.numerator);
        }else{
            Rational(rat1.numerator * rat2.denominator, rat1.denominator * rat2.numerator);
        }
    }
}

subaddRational(rat1 : Rational) -> Rational{
    Rational(rat1.numerator * -1, rat1.denominator);
}

calculateExpressionRec(expr : Expr, tree : Tree<Variable, Rational>) -> Rational{
    switch(expr){
        Add(e1, e2) : {
            addRational(calculateExpressionRec(e1, tree), calculateExpressionRec(e2, tree));
        };
        Sub(e1, e2) : {
            subRational(calculateExpressionRec(e1, tree), calculateExpressionRec(e2, tree));
        };
        Mul(e1, e2) : {
            mulRational(calculateExpressionRec(e1, tree), calculateExpressionRec(e2, tree));
        };
        Div(e1, e2) : {
            divRational(calculateExpressionRec(e1, tree), calculateExpressionRec(e2, tree));
        };
        Int(e1) : {
            Rational(e1, 1);
        };
        Parentheses(e1) : {
            calculateExpressionRec(e1, tree);
        }
        ReciprocalAdd(e1) : {
            subaddRational(calculateExpressionRec(e1, tree));
        }
        Variable(e1) : {
            number : Maybe<Rational> = lookupTree(tree, Variable(e1));
            value : Rational = either(number, Rational(0, 0));
            value;
        }
    }
}

simplifyFractions(expr : Expr) -> Expr{
    switch(expr){
        Add(e1, e2) : {
            Add(simplifyFractions(e1), simplifyFractions(e2));
        };
        Sub(e1, e2) : {
            Sub(simplifyFractions(e1), simplifyFractions(e2));
        };
        Mul(e1, e2) : {
            Mul(simplifyFractions(e1), simplifyFractions(e2));
        };
        Div(e1, e2) : {
            if(isSameStructType(e1, Div(Int(0), Int(0))) && isSameStructType(e2, Div(Int(0), Int(0)))){
                array1 : [Expr]= extractStructArguments(e1);
                array2 : [Expr]= extractStructArguments(e2);
                Div(Mul(array1[0],array2[1]), Mul(array1[1],array2[0]));
            }else{
                if(isSameStructType(e1, Div(Int(0), Int(0)))){
                    array1 : [Expr]= extractStructArguments(e1);
                    Div(array1[0],Mul(array1[1], e2));
                }else{
                    if(isSameStructType(e2, Div(Int(0), Int(0)))){
                        array1 : [Expr]= extractStructArguments(e2);
                        Div(Mul(e1,array1[1]),array1[0]);
                    }else{
                        Div(simplifyFractions(e1), simplifyFractions(e2));
                    }
                }
            }
        };
        Int(e1) : {
            Int(e1);
        };
        Parentheses(e1) : {
            Parentheses(simplifyFractions(e1));
        }
        ReciprocalAdd(e1) : {
            ReciprocalAdd(simplifyFractions(e1));
        }
        Variable(e1) : {
            Variable(e1);
        }
    }
}

simplifyRational(number : Rational) -> Rational{
    gcd : int = euclidianGCDAlg(Pair(number.numerator, number.denominator));
    Rational(number.numerator / gcd, number.denominator / gcd);
}

calculateExpression(context : ExecutionContext) -> Rational{
    astTree : Maybe<Expr> = context.expr;
    if(isSome(astTree)){
        astTreeValue : Expr = either(astTree, Int(0));
        astTreeValue2 : Expr = simplifyFractions(astTreeValue);
        //printAST(astTreeValue2);
        ret : Rational = calculateExpressionRec(astTreeValue2, context.tree);
        ret2 : Rational = simplifyRational(ret);
        ret2;
    }else{
        Rational(0, 0);
    }
}

printRational(value : Rational) -> void{
    println(i2s(value.numerator));
    println("______________");
    println(i2s(value.denominator));
}